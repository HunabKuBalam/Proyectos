Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program unit
Rule 2     program -> unit
Rule 3     unit -> statement
Rule 4     unit -> declaration
Rule 5     declaration -> type id_list SEMICOLON
Rule 6     type -> INT
Rule 7     type -> FLOAT
Rule 8     type -> CHAR
Rule 9     type -> BOOL
Rule 10    id_list -> ID
Rule 11    id_list -> ID COMMA id_list
Rule 12    statement -> assignment SEMICOLON
Rule 13    statement -> conditional
Rule 14    statement -> loop
Rule 15    statement -> io SEMICOLON
Rule 16    assignment -> ID ASSIGN expression
Rule 17    expression -> expression PLUS term
Rule 18    expression -> expression MINUS term
Rule 19    expression -> term
Rule 20    term -> term TIMES factor
Rule 21    term -> term DIVIDE factor
Rule 22    term -> factor
Rule 23    factor -> ID
Rule 24    factor -> NUM
Rule 25    factor -> LPAREN expression RPAREN
Rule 26    expression -> expression GT expression
Rule 27    expression -> expression LT expression
Rule 28    expression -> expression EQ expression
Rule 29    conditional -> IF LPAREN expression RPAREN block
Rule 30    conditional -> IF LPAREN expression RPAREN block ELSE block
Rule 31    loop -> WHILE LPAREN expression RPAREN block
Rule 32    loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block
Rule 33    io -> PRINTF LPAREN argument RPAREN
Rule 34    io -> SCANF LPAREN argument RPAREN
Rule 35    argument -> CAD COMMA ID
Rule 36    argument -> CAD COMMA AMPERSAND ID
Rule 37    argument -> ID
Rule 38    block -> LBRACE program RBRACE

Terminals, with rules where they appear

AMPERSAND            : 36
ASSIGN               : 16
BOOL                 : 9
CAD                  : 35 36
CHAR                 : 8
COMMA                : 11 35 36
DIVIDE               : 21
ELSE                 : 30
EQ                   : 28
FLOAT                : 7
FOR                  : 32
GT                   : 26
ID                   : 10 11 16 23 35 36 37
IF                   : 29 30
INT                  : 6
LBRACE               : 38
LPAREN               : 25 29 30 31 32 33 34
LT                   : 27
MINUS                : 18
NUM                  : 24
PLUS                 : 17
PRINTF               : 33
RBRACE               : 38
RPAREN               : 25 29 30 31 32 33 34
SCANF                : 34
SEMICOLON            : 5 12 15 32 32
TIMES                : 20
WHILE                : 31
error                : 

Nonterminals, with rules where they appear

argument             : 33 34
assignment           : 12 32 32
block                : 29 30 30 31 32
conditional          : 13
declaration          : 4
expression           : 16 17 18 25 26 26 27 27 28 28 29 30 31 32
factor               : 20 21 22
id_list              : 5 11
io                   : 15
loop                 : 14
program              : 1 38 0
statement            : 3
term                 : 17 18 19 20 21
type                 : 5
unit                 : 1 2

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program unit
    (2) program -> . unit
    (3) unit -> . statement
    (4) unit -> . declaration
    (12) statement -> . assignment SEMICOLON
    (13) statement -> . conditional
    (14) statement -> . loop
    (15) statement -> . io SEMICOLON
    (5) declaration -> . type id_list SEMICOLON
    (16) assignment -> . ID ASSIGN expression
    (29) conditional -> . IF LPAREN expression RPAREN block
    (30) conditional -> . IF LPAREN expression RPAREN block ELSE block
    (31) loop -> . WHILE LPAREN expression RPAREN block
    (32) loop -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block
    (33) io -> . PRINTF LPAREN argument RPAREN
    (34) io -> . SCANF LPAREN argument RPAREN
    (6) type -> . INT
    (7) type -> . FLOAT
    (8) type -> . CHAR
    (9) type -> . BOOL

    ID              shift and go to state 10
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13
    PRINTF          shift and go to state 14
    SCANF           shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19

    program                        shift and go to state 1
    unit                           shift and go to state 2
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    conditional                    shift and go to state 6
    loop                           shift and go to state 7
    io                             shift and go to state 8
    type                           shift and go to state 9

state 1

    (0) S' -> program .
    (1) program -> program . unit
    (3) unit -> . statement
    (4) unit -> . declaration
    (12) statement -> . assignment SEMICOLON
    (13) statement -> . conditional
    (14) statement -> . loop
    (15) statement -> . io SEMICOLON
    (5) declaration -> . type id_list SEMICOLON
    (16) assignment -> . ID ASSIGN expression
    (29) conditional -> . IF LPAREN expression RPAREN block
    (30) conditional -> . IF LPAREN expression RPAREN block ELSE block
    (31) loop -> . WHILE LPAREN expression RPAREN block
    (32) loop -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block
    (33) io -> . PRINTF LPAREN argument RPAREN
    (34) io -> . SCANF LPAREN argument RPAREN
    (6) type -> . INT
    (7) type -> . FLOAT
    (8) type -> . CHAR
    (9) type -> . BOOL

    ID              shift and go to state 10
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13
    PRINTF          shift and go to state 14
    SCANF           shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19

    unit                           shift and go to state 20
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    conditional                    shift and go to state 6
    loop                           shift and go to state 7
    io                             shift and go to state 8
    type                           shift and go to state 9

state 2

    (2) program -> unit .

    ID              reduce using rule 2 (program -> unit .)
    IF              reduce using rule 2 (program -> unit .)
    WHILE           reduce using rule 2 (program -> unit .)
    FOR             reduce using rule 2 (program -> unit .)
    PRINTF          reduce using rule 2 (program -> unit .)
    SCANF           reduce using rule 2 (program -> unit .)
    INT             reduce using rule 2 (program -> unit .)
    FLOAT           reduce using rule 2 (program -> unit .)
    CHAR            reduce using rule 2 (program -> unit .)
    BOOL            reduce using rule 2 (program -> unit .)
    $end            reduce using rule 2 (program -> unit .)
    RBRACE          reduce using rule 2 (program -> unit .)


state 3

    (3) unit -> statement .

    ID              reduce using rule 3 (unit -> statement .)
    IF              reduce using rule 3 (unit -> statement .)
    WHILE           reduce using rule 3 (unit -> statement .)
    FOR             reduce using rule 3 (unit -> statement .)
    PRINTF          reduce using rule 3 (unit -> statement .)
    SCANF           reduce using rule 3 (unit -> statement .)
    INT             reduce using rule 3 (unit -> statement .)
    FLOAT           reduce using rule 3 (unit -> statement .)
    CHAR            reduce using rule 3 (unit -> statement .)
    BOOL            reduce using rule 3 (unit -> statement .)
    $end            reduce using rule 3 (unit -> statement .)
    RBRACE          reduce using rule 3 (unit -> statement .)


state 4

    (4) unit -> declaration .

    ID              reduce using rule 4 (unit -> declaration .)
    IF              reduce using rule 4 (unit -> declaration .)
    WHILE           reduce using rule 4 (unit -> declaration .)
    FOR             reduce using rule 4 (unit -> declaration .)
    PRINTF          reduce using rule 4 (unit -> declaration .)
    SCANF           reduce using rule 4 (unit -> declaration .)
    INT             reduce using rule 4 (unit -> declaration .)
    FLOAT           reduce using rule 4 (unit -> declaration .)
    CHAR            reduce using rule 4 (unit -> declaration .)
    BOOL            reduce using rule 4 (unit -> declaration .)
    $end            reduce using rule 4 (unit -> declaration .)
    RBRACE          reduce using rule 4 (unit -> declaration .)


state 5

    (12) statement -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 21


state 6

    (13) statement -> conditional .

    ID              reduce using rule 13 (statement -> conditional .)
    IF              reduce using rule 13 (statement -> conditional .)
    WHILE           reduce using rule 13 (statement -> conditional .)
    FOR             reduce using rule 13 (statement -> conditional .)
    PRINTF          reduce using rule 13 (statement -> conditional .)
    SCANF           reduce using rule 13 (statement -> conditional .)
    INT             reduce using rule 13 (statement -> conditional .)
    FLOAT           reduce using rule 13 (statement -> conditional .)
    CHAR            reduce using rule 13 (statement -> conditional .)
    BOOL            reduce using rule 13 (statement -> conditional .)
    $end            reduce using rule 13 (statement -> conditional .)
    RBRACE          reduce using rule 13 (statement -> conditional .)


state 7

    (14) statement -> loop .

    ID              reduce using rule 14 (statement -> loop .)
    IF              reduce using rule 14 (statement -> loop .)
    WHILE           reduce using rule 14 (statement -> loop .)
    FOR             reduce using rule 14 (statement -> loop .)
    PRINTF          reduce using rule 14 (statement -> loop .)
    SCANF           reduce using rule 14 (statement -> loop .)
    INT             reduce using rule 14 (statement -> loop .)
    FLOAT           reduce using rule 14 (statement -> loop .)
    CHAR            reduce using rule 14 (statement -> loop .)
    BOOL            reduce using rule 14 (statement -> loop .)
    $end            reduce using rule 14 (statement -> loop .)
    RBRACE          reduce using rule 14 (statement -> loop .)


state 8

    (15) statement -> io . SEMICOLON

    SEMICOLON       shift and go to state 22


state 9

    (5) declaration -> type . id_list SEMICOLON
    (10) id_list -> . ID
    (11) id_list -> . ID COMMA id_list

    ID              shift and go to state 24

    id_list                        shift and go to state 23

state 10

    (16) assignment -> ID . ASSIGN expression

    ASSIGN          shift and go to state 25


state 11

    (29) conditional -> IF . LPAREN expression RPAREN block
    (30) conditional -> IF . LPAREN expression RPAREN block ELSE block

    LPAREN          shift and go to state 26


state 12

    (31) loop -> WHILE . LPAREN expression RPAREN block

    LPAREN          shift and go to state 27


state 13

    (32) loop -> FOR . LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block

    LPAREN          shift and go to state 28


state 14

    (33) io -> PRINTF . LPAREN argument RPAREN

    LPAREN          shift and go to state 29


state 15

    (34) io -> SCANF . LPAREN argument RPAREN

    LPAREN          shift and go to state 30


state 16

    (6) type -> INT .

    ID              reduce using rule 6 (type -> INT .)


state 17

    (7) type -> FLOAT .

    ID              reduce using rule 7 (type -> FLOAT .)


state 18

    (8) type -> CHAR .

    ID              reduce using rule 8 (type -> CHAR .)


state 19

    (9) type -> BOOL .

    ID              reduce using rule 9 (type -> BOOL .)


state 20

    (1) program -> program unit .

    ID              reduce using rule 1 (program -> program unit .)
    IF              reduce using rule 1 (program -> program unit .)
    WHILE           reduce using rule 1 (program -> program unit .)
    FOR             reduce using rule 1 (program -> program unit .)
    PRINTF          reduce using rule 1 (program -> program unit .)
    SCANF           reduce using rule 1 (program -> program unit .)
    INT             reduce using rule 1 (program -> program unit .)
    FLOAT           reduce using rule 1 (program -> program unit .)
    CHAR            reduce using rule 1 (program -> program unit .)
    BOOL            reduce using rule 1 (program -> program unit .)
    $end            reduce using rule 1 (program -> program unit .)
    RBRACE          reduce using rule 1 (program -> program unit .)


state 21

    (12) statement -> assignment SEMICOLON .

    ID              reduce using rule 12 (statement -> assignment SEMICOLON .)
    IF              reduce using rule 12 (statement -> assignment SEMICOLON .)
    WHILE           reduce using rule 12 (statement -> assignment SEMICOLON .)
    FOR             reduce using rule 12 (statement -> assignment SEMICOLON .)
    PRINTF          reduce using rule 12 (statement -> assignment SEMICOLON .)
    SCANF           reduce using rule 12 (statement -> assignment SEMICOLON .)
    INT             reduce using rule 12 (statement -> assignment SEMICOLON .)
    FLOAT           reduce using rule 12 (statement -> assignment SEMICOLON .)
    CHAR            reduce using rule 12 (statement -> assignment SEMICOLON .)
    BOOL            reduce using rule 12 (statement -> assignment SEMICOLON .)
    $end            reduce using rule 12 (statement -> assignment SEMICOLON .)
    RBRACE          reduce using rule 12 (statement -> assignment SEMICOLON .)


state 22

    (15) statement -> io SEMICOLON .

    ID              reduce using rule 15 (statement -> io SEMICOLON .)
    IF              reduce using rule 15 (statement -> io SEMICOLON .)
    WHILE           reduce using rule 15 (statement -> io SEMICOLON .)
    FOR             reduce using rule 15 (statement -> io SEMICOLON .)
    PRINTF          reduce using rule 15 (statement -> io SEMICOLON .)
    SCANF           reduce using rule 15 (statement -> io SEMICOLON .)
    INT             reduce using rule 15 (statement -> io SEMICOLON .)
    FLOAT           reduce using rule 15 (statement -> io SEMICOLON .)
    CHAR            reduce using rule 15 (statement -> io SEMICOLON .)
    BOOL            reduce using rule 15 (statement -> io SEMICOLON .)
    $end            reduce using rule 15 (statement -> io SEMICOLON .)
    RBRACE          reduce using rule 15 (statement -> io SEMICOLON .)


state 23

    (5) declaration -> type id_list . SEMICOLON

    SEMICOLON       shift and go to state 31


state 24

    (10) id_list -> ID .
    (11) id_list -> ID . COMMA id_list

    SEMICOLON       reduce using rule 10 (id_list -> ID .)
    COMMA           shift and go to state 32


state 25

    (16) assignment -> ID ASSIGN . expression
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (26) expression -> . expression GT expression
    (27) expression -> . expression LT expression
    (28) expression -> . expression EQ expression
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 34
    term                           shift and go to state 35
    factor                         shift and go to state 36

state 26

    (29) conditional -> IF LPAREN . expression RPAREN block
    (30) conditional -> IF LPAREN . expression RPAREN block ELSE block
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (26) expression -> . expression GT expression
    (27) expression -> . expression LT expression
    (28) expression -> . expression EQ expression
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 39
    term                           shift and go to state 35
    factor                         shift and go to state 36

state 27

    (31) loop -> WHILE LPAREN . expression RPAREN block
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (26) expression -> . expression GT expression
    (27) expression -> . expression LT expression
    (28) expression -> . expression EQ expression
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 40
    term                           shift and go to state 35
    factor                         shift and go to state 36

state 28

    (32) loop -> FOR LPAREN . assignment SEMICOLON expression SEMICOLON assignment RPAREN block
    (16) assignment -> . ID ASSIGN expression

    ID              shift and go to state 10

    assignment                     shift and go to state 41

state 29

    (33) io -> PRINTF LPAREN . argument RPAREN
    (35) argument -> . CAD COMMA ID
    (36) argument -> . CAD COMMA AMPERSAND ID
    (37) argument -> . ID

    CAD             shift and go to state 43
    ID              shift and go to state 44

    argument                       shift and go to state 42

state 30

    (34) io -> SCANF LPAREN . argument RPAREN
    (35) argument -> . CAD COMMA ID
    (36) argument -> . CAD COMMA AMPERSAND ID
    (37) argument -> . ID

    CAD             shift and go to state 43
    ID              shift and go to state 44

    argument                       shift and go to state 45

state 31

    (5) declaration -> type id_list SEMICOLON .

    ID              reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    IF              reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    WHILE           reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    FOR             reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    PRINTF          reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    SCANF           reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    INT             reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    FLOAT           reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    CHAR            reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    BOOL            reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    $end            reduce using rule 5 (declaration -> type id_list SEMICOLON .)
    RBRACE          reduce using rule 5 (declaration -> type id_list SEMICOLON .)


state 32

    (11) id_list -> ID COMMA . id_list
    (10) id_list -> . ID
    (11) id_list -> . ID COMMA id_list

    ID              shift and go to state 24

    id_list                        shift and go to state 46

state 33

    (23) factor -> ID .

    TIMES           reduce using rule 23 (factor -> ID .)
    DIVIDE          reduce using rule 23 (factor -> ID .)
    PLUS            reduce using rule 23 (factor -> ID .)
    MINUS           reduce using rule 23 (factor -> ID .)
    GT              reduce using rule 23 (factor -> ID .)
    LT              reduce using rule 23 (factor -> ID .)
    EQ              reduce using rule 23 (factor -> ID .)
    SEMICOLON       reduce using rule 23 (factor -> ID .)
    RPAREN          reduce using rule 23 (factor -> ID .)


state 34

    (16) assignment -> ID ASSIGN expression .
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term
    (26) expression -> expression . GT expression
    (27) expression -> expression . LT expression
    (28) expression -> expression . EQ expression

    SEMICOLON       reduce using rule 16 (assignment -> ID ASSIGN expression .)
    RPAREN          reduce using rule 16 (assignment -> ID ASSIGN expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    EQ              shift and go to state 51


state 35

    (19) expression -> term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    PLUS            reduce using rule 19 (expression -> term .)
    MINUS           reduce using rule 19 (expression -> term .)
    GT              reduce using rule 19 (expression -> term .)
    LT              reduce using rule 19 (expression -> term .)
    EQ              reduce using rule 19 (expression -> term .)
    SEMICOLON       reduce using rule 19 (expression -> term .)
    RPAREN          reduce using rule 19 (expression -> term .)
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53


state 36

    (22) term -> factor .

    TIMES           reduce using rule 22 (term -> factor .)
    DIVIDE          reduce using rule 22 (term -> factor .)
    PLUS            reduce using rule 22 (term -> factor .)
    MINUS           reduce using rule 22 (term -> factor .)
    GT              reduce using rule 22 (term -> factor .)
    LT              reduce using rule 22 (term -> factor .)
    EQ              reduce using rule 22 (term -> factor .)
    SEMICOLON       reduce using rule 22 (term -> factor .)
    RPAREN          reduce using rule 22 (term -> factor .)


state 37

    (24) factor -> NUM .

    TIMES           reduce using rule 24 (factor -> NUM .)
    DIVIDE          reduce using rule 24 (factor -> NUM .)
    PLUS            reduce using rule 24 (factor -> NUM .)
    MINUS           reduce using rule 24 (factor -> NUM .)
    GT              reduce using rule 24 (factor -> NUM .)
    LT              reduce using rule 24 (factor -> NUM .)
    EQ              reduce using rule 24 (factor -> NUM .)
    SEMICOLON       reduce using rule 24 (factor -> NUM .)
    RPAREN          reduce using rule 24 (factor -> NUM .)


state 38

    (25) factor -> LPAREN . expression RPAREN
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (26) expression -> . expression GT expression
    (27) expression -> . expression LT expression
    (28) expression -> . expression EQ expression
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 54
    term                           shift and go to state 35
    factor                         shift and go to state 36

state 39

    (29) conditional -> IF LPAREN expression . RPAREN block
    (30) conditional -> IF LPAREN expression . RPAREN block ELSE block
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term
    (26) expression -> expression . GT expression
    (27) expression -> expression . LT expression
    (28) expression -> expression . EQ expression

    RPAREN          shift and go to state 55
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    EQ              shift and go to state 51


state 40

    (31) loop -> WHILE LPAREN expression . RPAREN block
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term
    (26) expression -> expression . GT expression
    (27) expression -> expression . LT expression
    (28) expression -> expression . EQ expression

    RPAREN          shift and go to state 56
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    EQ              shift and go to state 51


state 41

    (32) loop -> FOR LPAREN assignment . SEMICOLON expression SEMICOLON assignment RPAREN block

    SEMICOLON       shift and go to state 57


state 42

    (33) io -> PRINTF LPAREN argument . RPAREN

    RPAREN          shift and go to state 58


state 43

    (35) argument -> CAD . COMMA ID
    (36) argument -> CAD . COMMA AMPERSAND ID

    COMMA           shift and go to state 59


state 44

    (37) argument -> ID .

    RPAREN          reduce using rule 37 (argument -> ID .)


state 45

    (34) io -> SCANF LPAREN argument . RPAREN

    RPAREN          shift and go to state 60


state 46

    (11) id_list -> ID COMMA id_list .

    SEMICOLON       reduce using rule 11 (id_list -> ID COMMA id_list .)


state 47

    (17) expression -> expression PLUS . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    term                           shift and go to state 61
    factor                         shift and go to state 36

state 48

    (18) expression -> expression MINUS . term
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    term                           shift and go to state 62
    factor                         shift and go to state 36

state 49

    (26) expression -> expression GT . expression
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (26) expression -> . expression GT expression
    (27) expression -> . expression LT expression
    (28) expression -> . expression EQ expression
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 63
    term                           shift and go to state 35
    factor                         shift and go to state 36

state 50

    (27) expression -> expression LT . expression
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (26) expression -> . expression GT expression
    (27) expression -> . expression LT expression
    (28) expression -> . expression EQ expression
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 64
    term                           shift and go to state 35
    factor                         shift and go to state 36

state 51

    (28) expression -> expression EQ . expression
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (26) expression -> . expression GT expression
    (27) expression -> . expression LT expression
    (28) expression -> . expression EQ expression
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 65
    term                           shift and go to state 35
    factor                         shift and go to state 36

state 52

    (20) term -> term TIMES . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    factor                         shift and go to state 66

state 53

    (21) term -> term DIVIDE . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    factor                         shift and go to state 67

state 54

    (25) factor -> LPAREN expression . RPAREN
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term
    (26) expression -> expression . GT expression
    (27) expression -> expression . LT expression
    (28) expression -> expression . EQ expression

    RPAREN          shift and go to state 68
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    EQ              shift and go to state 51


state 55

    (29) conditional -> IF LPAREN expression RPAREN . block
    (30) conditional -> IF LPAREN expression RPAREN . block ELSE block
    (38) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 70

    block                          shift and go to state 69

state 56

    (31) loop -> WHILE LPAREN expression RPAREN . block
    (38) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 70

    block                          shift and go to state 71

state 57

    (32) loop -> FOR LPAREN assignment SEMICOLON . expression SEMICOLON assignment RPAREN block
    (17) expression -> . expression PLUS term
    (18) expression -> . expression MINUS term
    (19) expression -> . term
    (26) expression -> . expression GT expression
    (27) expression -> . expression LT expression
    (28) expression -> . expression EQ expression
    (20) term -> . term TIMES factor
    (21) term -> . term DIVIDE factor
    (22) term -> . factor
    (23) factor -> . ID
    (24) factor -> . NUM
    (25) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 33
    NUM             shift and go to state 37
    LPAREN          shift and go to state 38

    expression                     shift and go to state 72
    term                           shift and go to state 35
    factor                         shift and go to state 36

state 58

    (33) io -> PRINTF LPAREN argument RPAREN .

    SEMICOLON       reduce using rule 33 (io -> PRINTF LPAREN argument RPAREN .)


state 59

    (35) argument -> CAD COMMA . ID
    (36) argument -> CAD COMMA . AMPERSAND ID

    ID              shift and go to state 73
    AMPERSAND       shift and go to state 74


state 60

    (34) io -> SCANF LPAREN argument RPAREN .

    SEMICOLON       reduce using rule 34 (io -> SCANF LPAREN argument RPAREN .)


state 61

    (17) expression -> expression PLUS term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    PLUS            reduce using rule 17 (expression -> expression PLUS term .)
    MINUS           reduce using rule 17 (expression -> expression PLUS term .)
    GT              reduce using rule 17 (expression -> expression PLUS term .)
    LT              reduce using rule 17 (expression -> expression PLUS term .)
    EQ              reduce using rule 17 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 17 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 17 (expression -> expression PLUS term .)
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53


state 62

    (18) expression -> expression MINUS term .
    (20) term -> term . TIMES factor
    (21) term -> term . DIVIDE factor

    PLUS            reduce using rule 18 (expression -> expression MINUS term .)
    MINUS           reduce using rule 18 (expression -> expression MINUS term .)
    GT              reduce using rule 18 (expression -> expression MINUS term .)
    LT              reduce using rule 18 (expression -> expression MINUS term .)
    EQ              reduce using rule 18 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 18 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 18 (expression -> expression MINUS term .)
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53


state 63

    (26) expression -> expression GT expression .
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term
    (26) expression -> expression . GT expression
    (27) expression -> expression . LT expression
    (28) expression -> expression . EQ expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
    SEMICOLON       reduce using rule 26 (expression -> expression GT expression .)
    RPAREN          reduce using rule 26 (expression -> expression GT expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    EQ              shift and go to state 51

  ! PLUS            [ reduce using rule 26 (expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 26 (expression -> expression GT expression .) ]
  ! GT              [ reduce using rule 26 (expression -> expression GT expression .) ]
  ! LT              [ reduce using rule 26 (expression -> expression GT expression .) ]
  ! EQ              [ reduce using rule 26 (expression -> expression GT expression .) ]


state 64

    (27) expression -> expression LT expression .
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term
    (26) expression -> expression . GT expression
    (27) expression -> expression . LT expression
    (28) expression -> expression . EQ expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
    SEMICOLON       reduce using rule 27 (expression -> expression LT expression .)
    RPAREN          reduce using rule 27 (expression -> expression LT expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    EQ              shift and go to state 51

  ! PLUS            [ reduce using rule 27 (expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 27 (expression -> expression LT expression .) ]
  ! GT              [ reduce using rule 27 (expression -> expression LT expression .) ]
  ! LT              [ reduce using rule 27 (expression -> expression LT expression .) ]
  ! EQ              [ reduce using rule 27 (expression -> expression LT expression .) ]


state 65

    (28) expression -> expression EQ expression .
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term
    (26) expression -> expression . GT expression
    (27) expression -> expression . LT expression
    (28) expression -> expression . EQ expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
    SEMICOLON       reduce using rule 28 (expression -> expression EQ expression .)
    RPAREN          reduce using rule 28 (expression -> expression EQ expression .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    EQ              shift and go to state 51

  ! PLUS            [ reduce using rule 28 (expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 28 (expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 28 (expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 28 (expression -> expression EQ expression .) ]
  ! EQ              [ reduce using rule 28 (expression -> expression EQ expression .) ]


state 66

    (20) term -> term TIMES factor .

    TIMES           reduce using rule 20 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 20 (term -> term TIMES factor .)
    PLUS            reduce using rule 20 (term -> term TIMES factor .)
    MINUS           reduce using rule 20 (term -> term TIMES factor .)
    GT              reduce using rule 20 (term -> term TIMES factor .)
    LT              reduce using rule 20 (term -> term TIMES factor .)
    EQ              reduce using rule 20 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 20 (term -> term TIMES factor .)
    RPAREN          reduce using rule 20 (term -> term TIMES factor .)


state 67

    (21) term -> term DIVIDE factor .

    TIMES           reduce using rule 21 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 21 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 21 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 21 (term -> term DIVIDE factor .)
    GT              reduce using rule 21 (term -> term DIVIDE factor .)
    LT              reduce using rule 21 (term -> term DIVIDE factor .)
    EQ              reduce using rule 21 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 21 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 21 (term -> term DIVIDE factor .)


state 68

    (25) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    EQ              reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 25 (factor -> LPAREN expression RPAREN .)


state 69

    (29) conditional -> IF LPAREN expression RPAREN block .
    (30) conditional -> IF LPAREN expression RPAREN block . ELSE block

    ID              reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    IF              reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    WHILE           reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    FOR             reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    PRINTF          reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    SCANF           reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    INT             reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    FLOAT           reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    CHAR            reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    BOOL            reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    $end            reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    RBRACE          reduce using rule 29 (conditional -> IF LPAREN expression RPAREN block .)
    ELSE            shift and go to state 75


state 70

    (38) block -> LBRACE . program RBRACE
    (1) program -> . program unit
    (2) program -> . unit
    (3) unit -> . statement
    (4) unit -> . declaration
    (12) statement -> . assignment SEMICOLON
    (13) statement -> . conditional
    (14) statement -> . loop
    (15) statement -> . io SEMICOLON
    (5) declaration -> . type id_list SEMICOLON
    (16) assignment -> . ID ASSIGN expression
    (29) conditional -> . IF LPAREN expression RPAREN block
    (30) conditional -> . IF LPAREN expression RPAREN block ELSE block
    (31) loop -> . WHILE LPAREN expression RPAREN block
    (32) loop -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block
    (33) io -> . PRINTF LPAREN argument RPAREN
    (34) io -> . SCANF LPAREN argument RPAREN
    (6) type -> . INT
    (7) type -> . FLOAT
    (8) type -> . CHAR
    (9) type -> . BOOL

    ID              shift and go to state 10
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13
    PRINTF          shift and go to state 14
    SCANF           shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19

    program                        shift and go to state 76
    unit                           shift and go to state 2
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    conditional                    shift and go to state 6
    loop                           shift and go to state 7
    io                             shift and go to state 8
    type                           shift and go to state 9

state 71

    (31) loop -> WHILE LPAREN expression RPAREN block .

    ID              reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    IF              reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    WHILE           reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    FOR             reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    PRINTF          reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    SCANF           reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    INT             reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    FLOAT           reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    CHAR            reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    BOOL            reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    $end            reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)
    RBRACE          reduce using rule 31 (loop -> WHILE LPAREN expression RPAREN block .)


state 72

    (32) loop -> FOR LPAREN assignment SEMICOLON expression . SEMICOLON assignment RPAREN block
    (17) expression -> expression . PLUS term
    (18) expression -> expression . MINUS term
    (26) expression -> expression . GT expression
    (27) expression -> expression . LT expression
    (28) expression -> expression . EQ expression

    SEMICOLON       shift and go to state 77
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    GT              shift and go to state 49
    LT              shift and go to state 50
    EQ              shift and go to state 51


state 73

    (35) argument -> CAD COMMA ID .

    RPAREN          reduce using rule 35 (argument -> CAD COMMA ID .)


state 74

    (36) argument -> CAD COMMA AMPERSAND . ID

    ID              shift and go to state 78


state 75

    (30) conditional -> IF LPAREN expression RPAREN block ELSE . block
    (38) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 70

    block                          shift and go to state 79

state 76

    (38) block -> LBRACE program . RBRACE
    (1) program -> program . unit
    (3) unit -> . statement
    (4) unit -> . declaration
    (12) statement -> . assignment SEMICOLON
    (13) statement -> . conditional
    (14) statement -> . loop
    (15) statement -> . io SEMICOLON
    (5) declaration -> . type id_list SEMICOLON
    (16) assignment -> . ID ASSIGN expression
    (29) conditional -> . IF LPAREN expression RPAREN block
    (30) conditional -> . IF LPAREN expression RPAREN block ELSE block
    (31) loop -> . WHILE LPAREN expression RPAREN block
    (32) loop -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block
    (33) io -> . PRINTF LPAREN argument RPAREN
    (34) io -> . SCANF LPAREN argument RPAREN
    (6) type -> . INT
    (7) type -> . FLOAT
    (8) type -> . CHAR
    (9) type -> . BOOL

    RBRACE          shift and go to state 80
    ID              shift and go to state 10
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13
    PRINTF          shift and go to state 14
    SCANF           shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    BOOL            shift and go to state 19

    unit                           shift and go to state 20
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    assignment                     shift and go to state 5
    conditional                    shift and go to state 6
    loop                           shift and go to state 7
    io                             shift and go to state 8
    type                           shift and go to state 9

state 77

    (32) loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON . assignment RPAREN block
    (16) assignment -> . ID ASSIGN expression

    ID              shift and go to state 10

    assignment                     shift and go to state 81

state 78

    (36) argument -> CAD COMMA AMPERSAND ID .

    RPAREN          reduce using rule 36 (argument -> CAD COMMA AMPERSAND ID .)


state 79

    (30) conditional -> IF LPAREN expression RPAREN block ELSE block .

    ID              reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    IF              reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    WHILE           reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    FOR             reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    PRINTF          reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    SCANF           reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    INT             reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    FLOAT           reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    CHAR            reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    BOOL            reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    $end            reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)
    RBRACE          reduce using rule 30 (conditional -> IF LPAREN expression RPAREN block ELSE block .)


state 80

    (38) block -> LBRACE program RBRACE .

    ELSE            reduce using rule 38 (block -> LBRACE program RBRACE .)
    ID              reduce using rule 38 (block -> LBRACE program RBRACE .)
    IF              reduce using rule 38 (block -> LBRACE program RBRACE .)
    WHILE           reduce using rule 38 (block -> LBRACE program RBRACE .)
    FOR             reduce using rule 38 (block -> LBRACE program RBRACE .)
    PRINTF          reduce using rule 38 (block -> LBRACE program RBRACE .)
    SCANF           reduce using rule 38 (block -> LBRACE program RBRACE .)
    INT             reduce using rule 38 (block -> LBRACE program RBRACE .)
    FLOAT           reduce using rule 38 (block -> LBRACE program RBRACE .)
    CHAR            reduce using rule 38 (block -> LBRACE program RBRACE .)
    BOOL            reduce using rule 38 (block -> LBRACE program RBRACE .)
    $end            reduce using rule 38 (block -> LBRACE program RBRACE .)
    RBRACE          reduce using rule 38 (block -> LBRACE program RBRACE .)


state 81

    (32) loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment . RPAREN block

    RPAREN          shift and go to state 82


state 82

    (32) loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN . block
    (38) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 70

    block                          shift and go to state 83

state 83

    (32) loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .

    ID              reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    IF              reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    WHILE           reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    FOR             reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    PRINTF          reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    SCANF           reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    INT             reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    FLOAT           reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    CHAR            reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    BOOL            reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    $end            reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)
    RBRACE          reduce using rule 32 (loop -> FOR LPAREN assignment SEMICOLON expression SEMICOLON assignment RPAREN block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 64 resolved as shift
WARNING: shift/reduce conflict for GT in state 64 resolved as shift
WARNING: shift/reduce conflict for LT in state 64 resolved as shift
WARNING: shift/reduce conflict for EQ in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for GT in state 65 resolved as shift
WARNING: shift/reduce conflict for LT in state 65 resolved as shift
WARNING: shift/reduce conflict for EQ in state 65 resolved as shift
